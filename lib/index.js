// Generated by CoffeeScript 1.9.3
(function() {
  var EPub, Q, _, cheerio, ejs, exec, fs, fsextra, path, removeDiacritics, request, uslug, uuid;

  exec = require("child_process").exec;

  path = require("path");

  fs = require("fs");

  Q = require("q");

  _ = require("underscore");

  uslug = require("uslug");

  ejs = require("ejs");

  cheerio = require("cheerio");

  request = require("superagent");

  fsextra = require("fs-extra");

  removeDiacritics = require('diacritics').remove;

  uuid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r;
      r = Math.random() * 16 | 0;
      return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
    });
  };

  EPub = (function() {
    function EPub(options, output) {
      var self;
      this.options = options;
      self = this;
      this.defer = new Q.defer();
      if (output) {
        this.options.output = output;
      }
      if (!this.options.output) {
        console.error(new Error("No Output Path"));
        this.defer.reject(new Error("No output path"));
        return false;
      }
      if (!options.title || !options.content) {
        console.log("options not valid");
        return false;
      }
      this.options = _.extend({
        description: options.title,
        publisher: "anonymous",
        author: ["anonymous"],
        tocTitle: "Table Of Contents",
        appendChapterTitles: true,
        date: new Date().toISOString(),
        lang: "en",
        fonts: [],
        customOpfTemplatePath: null,
        customNcxTocTemplatePath: null,
        customHtmlTocTemplatePath: null,
        docType: "html"
      }, options);
      if (this.options.docType === "xhtml") {
        this.options.mediaType = "application/xhtml+xml";
        this.options.docHeader = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"" + self.options.lang + "\">";
      } else {
        this.options.mediaType = "text/html";
        this.options.docHeader = "<!DOCTYPE html>\n<html lang=\"" + self.options.lang + "\">";
      }
      if (_.isString(this.options.author)) {
        this.options.author = [this.options.author];
      }
      if (_.isEmpty(this.options.author)) {
        this.operator.author = ["anonymous"];
      }
      if (!this.options.tempDir) {
        this.options.tempDir = path.resolve(__dirname, "../tempDir/");
      }
      this.id = uuid();
      this.uuid = path.resolve(this.options.tempDir, this.id);
      this.options.uuid = this.uuid;
      this.options.id = this.id;
      this.options.images = [];
      this.options.content = _.map(this.options.content, function(content, index) {
        var $, titleSlug;
        titleSlug = uslug(removeDiacritics(content.title || "no title"));
        content.filePath = path.resolve(self.uuid, "./OEBPS/" + index + "_" + titleSlug + "." + self.options.docType);
        content.href = index + "_" + titleSlug + "." + self.options.docType;
        content.id = "item_" + index;
        content.author = content.author && _.isString(content.author) ? [content.author] : !content.author || !_.isArray(content.author) ? [] : content.author;
        $ = cheerio.load(content.data, {
          xmlMode: true
        });
        if ($("body").length) {
          $ = cheerio.load($("body").html());
        }
        $("img").each(function(index, elem) {
          var id, url;
          url = $(elem).attr("src");
          id = uuid();
          $(elem).attr("src", "images/" + id + ".jpg");
          return self.options.images.push({
            id: id,
            url: url
          });
        });
        content.data = $.html();
        return content;
      });
      this.render();
      this.promise = this.defer.promise;
      this;
    }

    EPub.prototype.render = function() {
      var self;
      self = this;
      return this.generateTempFile().then(function() {
        return self.downloadAllImage().fin(function() {
          return self.makeCover().then(function() {
            return self.genEpub().then(function(result) {
              return self.defer.resolve(result);
            }, function(err) {
              return self.defer.reject(err);
            });
          }, function(err) {
            return self.defer.reject(err);
          });
        }, function(err) {
          return self.defer.reject(err);
        });
      }, function(err) {
        return self.defer.reject(err);
      });
    };

    EPub.prototype.generateTempFile = function() {
      var base, generateDefer, htmlTocPath, ncxTocPath, opfPath, self;
      generateDefer = new Q.defer();
      self = this;
      if (!fs.existsSync(this.options.tempDir)) {
        fs.mkdirSync(this.options.tempDir);
      }
      fs.mkdirSync(this.uuid);
      fs.mkdirSync(path.resolve(this.uuid, "./OEBPS"));
      (base = this.options).css || (base.css = ".epub-author{color: #555;}.epub-link{margin-bottom: 30px;}.epub-link a{color: #666;font-size: 90%;}.toc-author{font-size: 90%;color: #555;}.toc-link{color: #999;font-size: 85%;display: block;}hr{border: 0;border-bottom: 1px solid #dedede;margin: 60px 10%;}");
      fs.writeFileSync(path.resolve(this.uuid, "./OEBPS/style.css"), this.options.css);
      if (self.options.fonts.length) {
        fs.mkdirSync(path.resolve(this.uuid, "./OEBPS/fonts"));
        this.options.fonts = _.map(this.options.fonts, function(font) {
          var filename;
          if (!fs.existsSync(font)) {
            generateDefer.reject(new Error('Custom font not found at ' + font + '.'));
            return generateDefer.promise;
          }
          filename = path.basename(font);
          fsextra.copySync(font, path.resolve(self.uuid, "./OEBPS/fonts/" + filename));
          return filename;
        });
      }
      fs.mkdirSync(path.resolve(this.uuid, "./OEBPS/images"));
      _.each(this.options.content, function(content) {
        var data;
        data = self.options.docHeader + "\n  <head>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n  <title>" + content.title + "</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" />\n  </head>\n<body>";
        data += content.title && self.options.appendChapterTitles ? "<h1>" + content.title + "</h1>" : "";
        data += content.title && content.author && content.author.length ? "<p class='epub-author'>" + (content.author.join(", ")) + "</p>" : "";
        data += content.title && content.url ? "<p class='epub-link'><a href='" + content.url + "'>" + content.url + "</a></p>" : "";
        data += content.data + "</body></html>";
        return fs.writeFileSync(content.filePath, data);
      });
      fs.writeFileSync(this.uuid + "/mimetype", "application/epub+zip");
      fs.mkdirSync(this.uuid + "/META-INF");
      fs.writeFileSync(this.uuid + "/META-INF/container.xml", "<?xml version=\"1.0\" encoding=\"UTF-8\" ?><container version=\"1.0\" xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\"><rootfiles><rootfile full-path=\"OEBPS/content.opf\" media-type=\"application/oebps-package+xml\"/></rootfiles></container>");
      fs.writeFileSync(this.uuid + "/META-INF/com.apple.ibooks.display-options.xml", "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<display_options>\n  <platform name=\"*\">\n    <option name=\"specified-fonts\">true</option>\n  </platform>\n</display_options>");
      opfPath = self.options.customOpfTemplatePath || path.resolve(__dirname, "./content.ejs");
      if (!fs.existsSync(opfPath)) {
        generateDefer.reject(new Error('Custom file to OPF template not found.'));
        return generateDefer.promise;
      }
      ncxTocPath = self.options.customNcxTocTemplatePath || path.resolve(__dirname, "./toc.ejs");
      if (!fs.existsSync(ncxTocPath)) {
        generateDefer.reject(new Error('Custom file the NCX toc template not found.'));
        return generateDefer.promise;
      }
      htmlTocPath = self.options.customHtmlTocTemplatePath || path.resolve(__dirname, "./content." + self.options.docType);
      if (!fs.existsSync(htmlTocPath)) {
        generateDefer.reject(new Error('Custom file to HTML toc template not found.'));
        return generateDefer.promise;
      }
      Q.all([Q.nfcall(ejs.renderFile, opfPath, self.options), Q.nfcall(ejs.renderFile, ncxTocPath, self.options), Q.nfcall(ejs.renderFile, htmlTocPath, self.options)]).spread(function(data1, data2, data3) {
        fs.writeFileSync(path.resolve(self.uuid, "./OEBPS/content.opf"), data1);
        fs.writeFileSync(path.resolve(self.uuid, "./OEBPS/toc.ncx"), data2);
        fs.writeFileSync(path.resolve(self.uuid, "./OEBPS/contents." + self.options.docType), data3);
        return generateDefer.resolve();
      }, function(err) {
        console.error(arguments);
        return generateDefer.reject(err);
      });
      return generateDefer.promise;
    };

    EPub.prototype.makeCover = function() {
      var coverDefer, destPath, userAgent, writeStream;
      userAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.116 Safari/537.36";
      coverDefer = new Q.defer();
      destPath = path.resolve(this.uuid, "./OEBPS/cover.jpg");
      if (this.options.cover) {
        writeStream = null;
        if (this.options.cover.slice(0, 4) === "http") {
          writeStream = request.get(this.options.cover).set({
            'User-Agent': userAgent
          });
          writeStream.pipe(fs.createWriteStream(destPath));
        } else {
          writeStream = fs.createReadStream(this.options.cover);
          writeStream.pipe(fs.createWriteStream(destPath));
        }
        writeStream.on("end", function() {
          console.log("[Success] cover image downloaded successfully!");
          return coverDefer.resolve();
        });
        writeStream.on("error", function(err) {
          console.log("Error", err);
          console.log(arguments);
          return coverDefer.reject(err);
        });
      } else {
        coverDefer.resolve();
      }
      return coverDefer.promise;
    };

    EPub.prototype.downloadImage = function(options) {
      var auxpath, downloadImageDefer, filename, requestAction, self, userAgent;
      self = this;
      userAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.116 Safari/537.36";
      if (!options.url && typeof options !== "string") {
        return false;
      }
      downloadImageDefer = new Q.defer();
      if (options.url.indexOf("file://") === 0) {
        filename = path.resolve(self.uuid, "./OEBPS/images/" + options.id + ".jpg");
        auxpath = options.url.substr(7);
        fsextra.copySync(auxpath, filename);
        return downloadImageDefer.resolve(options);
      } else {
        requestAction = request.get(options.url).set({
          'User-Agent': userAgent
        });
        filename = path.resolve(self.uuid, "./OEBPS/images/" + options.id + ".jpg");
        requestAction.pipe(fs.createWriteStream(filename));
        requestAction.on('error', function(err) {
          console.error('[Download Error]', 'Error while downloading', options.url, err);
          fs.unlinkSync(filename);
          return downloadImageDefer.reject(err);
        });
        requestAction.on('end', function() {
          console.log("[Download Success]", options.url);
          return downloadImageDefer.resolve(options);
        });
        return downloadImageDefer.promise;
      }
    };

    EPub.prototype.downloadAllImage = function() {
      var deferArray, imgDefer, self;
      self = this;
      imgDefer = new Q.defer();
      if (!self.options.images.length) {
        imgDefer.resolve();
      } else {
        deferArray = [];
        _.each(self.options.images, function(image) {
          return deferArray.push(self.downloadImage(image));
        });
        Q.all(deferArray).fin(function() {
          return imgDefer.resolve();
        });
      }
      return imgDefer.promise;
    };

    EPub.prototype.runCommand = function(cmd, option) {
      var defer;
      defer = new Q.defer();
      exec(cmd, option, function(err, stderr, stdout) {
        if (err) {
          console.error(cmd, stderr, stdout);
          defer.reject(err);
          return false;
        }
        if (stderr) {
          console.warn(stderr);
        }
        if (stdout && option.quite) {
          console.log(stdout);
        }
        return defer.resolve(stdout);
      });
      return defer.promise;
    };

    EPub.prototype.genEpub = function() {
      var cleanUp, cwd, filename, genDefer, initCmd, self, zipCmd;
      genDefer = new Q.defer();
      self = this;
      filename = "book.epub.zip";
      initCmd = "zip -q -X -0 " + filename + " mimetype";
      zipCmd = "zip -q -X -9 -r " + filename + " * -x mimetype " + filename;
      cleanUp = "mv " + filename + " book.epub && rm -f -r META-INF OEBPS mimetype";
      cleanUp = "mv " + filename + " book.epub";
      cwd = this.uuid;
      self.runCommand(initCmd, {
        cwd: cwd
      }).then(function() {
        return self.runCommand(zipCmd, {
          cwd: cwd
        }).then(function() {
          return self.runCommand(cleanUp, {
            cwd: cwd
          }).then(function() {
            var stream;
            stream = fs.createReadStream(path.resolve(self.uuid, "book.epub"));
            stream.pipe(fs.createWriteStream(self.options.output));
            stream.on("error", function(err) {
              console.error(err);
              return self.defer.reject(err);
            });
            return stream.on("end", function() {
              var currentDir;
              self.defer.resolve();
              currentDir = self.options.tempDir;
              return self.runCommand("rm -f -r " + self.id + "/", {
                cwd: currentDir
              });
            });
          }, function(err) {
            return genDefer.reject(err);
          });
        }, function(err) {
          return genDefer.reject(err);
        });
      }, function(err) {
        return genDefer.reject(err);
      });
      return genDefer.promise;
    };

    return EPub;

  })();

  module.exports = EPub;

}).call(this);
